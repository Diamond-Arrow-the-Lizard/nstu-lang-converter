using Core.Parser.AST.Nodes;
using Core.Parser.Interfaces.Models;
using Core.Parser.Interfaces.Repositories;
using Core.Parser.Models; 
using Core.Parser.Tokens;
using Core.Parser.Interfaces.AST;
using Core.Parser.AST.Nodes.StatementNodes;
using Core.Parser.AST.Nodes.ControlFlowNodes.LoopControlFlowNodes;
using Core.Parser.AST.Nodes.ControlFlowNodes.IfElseControlFlowNodes;
using Core.Parser.AST.Nodes.LiteralNodes;
using Core.Parser.AST.Nodes.ExpressionNodes; 

namespace Core.Parser.AST.ASTParser;

/// <summary>
/// Implements a recursive descent parser to construct an Abstract Syntax Tree (AST)
/// from a stream of tokens.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="Parser"/> class.
/// </remarks>
/// <param name="tokenRepository">The repository containing the token stream generated by the lexer.</param>
public class Parser(ITokenRepository tokenRepository) : IParser
{
    private readonly List<IToken> _tokens = tokenRepository.GetAllTokens().ToList();
    private int _position = 0;

    /// <summary>
    /// Gets the current token at the parser's current position.
    /// </summary>
    private IToken CurrentToken => _tokens[_position];

    /// <summary>
    /// Peeks at the next token without advancing the parser's position.
    /// </summary>
    /// <param name="offset">The offset from the current position to peek (default is 1 for the next token).</param>
    /// <returns>The token at the peeked position, or Eof if beyond bounds.</returns>
    private IToken Peek(int offset = 1)
    {
        int peekPosition = _position + offset;
        if (peekPosition >= _tokens.Count)
        {
            return new Token(TokenType.Eof, ""); // Return Eof token if beyond bounds
        }
        return _tokens[peekPosition];
    }

    /// <summary>
    /// Advances the parser to the next token and returns the current token.
    /// </summary>
    /// <returns>The token at the previous position.</returns>
    private IToken Advance()
    {
        IToken token = CurrentToken;
        _position++;
        return token;
    }

    /// <summary>
    /// Consumes the current token if its type matches the expected type, then advances.
    /// Throws a SyntaxException if the token type does not match.
    /// </summary>
    /// <param name="expectedType">The expected TokenType.</param>
    /// <returns>The consumed token.</returns>
    /// <exception cref="SyntaxException">Thrown if the current token's type does not match the expected type.</exception>
    private IToken Expect(TokenType expectedType)
    {
        if (CurrentToken.TokenType == expectedType)
        {
            return Advance();
        }
        throw new SyntaxException($"Expect: Unexpected token '{CurrentToken.Representation}' ({CurrentToken.TokenType}) at position {_position}. Expected '{expectedType}'.");
    }

    /// <summary>
    /// Checks if the given token type is a literal (Integer, Double, String, Bool).
    /// </summary>
    private bool IsLiteral(TokenType type)
    {
        return type == TokenType.Integer ||
               type == TokenType.Double ||
               type == TokenType.String;
    }

    /// <summary>
    /// Checks if the given token type is a variable type keyword.
    /// </summary>
    private bool IsTypeKeyword(TokenType type)
    {
        return type == TokenType.IntegerType ||
               type == TokenType.DoubleType ||
               type == TokenType.StringType;
    }

    /// <inheritdoc/>
    public ProgramNode Parse()
    {
        Expect(TokenType.ProgramBegin);
        List<IAstNode> statements = new();
        while (CurrentToken.TokenType != TokenType.ProgramEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            statements.Add(ParseStatement());
        }
        Expect(TokenType.ProgramEnd);
        Expect(TokenType.Eof); // Ensure Eof is at the very end of the file
        return new ProgramNode(statements);
    }

    /// <summary>
    /// Parses a single statement.
    /// </summary>
    /// <returns>An AST node representing the statement.</returns>
    /// <exception cref="SyntaxException">Thrown if an unexpected token is encountered.</exception>
    private IAstNode ParseStatement()
    {
        if (CurrentToken.TokenType == TokenType.Write)
        {
            return ParseWriteStatement();
        }
        else if (CurrentToken.TokenType == TokenType.Read)
        {
            return ParseReadStatement();
        }
        else if (CurrentToken.TokenType == TokenType.If)
        {
            return ParseIfStatement();
        }
        else if (CurrentToken.TokenType == TokenType.LoopBegin)
        {
            return ParseLoopStatement();
        }
        else if (CurrentToken.TokenType == TokenType.Return)
        {
            return ParseReturnStatement();
        }
        else if (IsTypeKeyword(CurrentToken.TokenType))
        {
            // Variable declaration statement: "цел X = 1 + 1;" or "цел X;"
            VariableDeclarationNode declaration = ParseVariableDeclaration();
            Expect(TokenType.Semicolon); 
            return declaration;
        }
        else if (CurrentToken.TokenType == TokenType.VariableName ||
                 IsLiteral(CurrentToken.TokenType) ||
                 CurrentToken.TokenType == TokenType.Add || // Potentially for unary plus
                 CurrentToken.TokenType == TokenType.Decrement) // Potentially for unary minus
        {
            // This handles expression statements, e.g., "Num1 = Num1 + 2 * 3;"
            IAstNode expressionStatement = ParseAssignmentExpression(); 
            Expect(TokenType.Semicolon); 
            return expressionStatement;
        }
        throw new SyntaxException($"ParseStatement: Unexpected token '{CurrentToken.Representation}' ({CurrentToken.TokenType}) at position {_position}. Expected a statement.");
    }

    /// <summary>
    /// Parses a variable declaration.
    /// Examples: "цел X;" or "цел X = 1 + 1;".
    /// </summary>
    /// <returns>A VariableDeclarationNode.</returns>
    private VariableDeclarationNode ParseVariableDeclaration()
    {
        TokenType variableType = Advance().TokenType; // Consume IntegerType, DoubleType, or StringType
        string variableName = Expect(TokenType.VariableName).Representation; // Consume variable name

        IAstNode? initialValue = null;
        if (CurrentToken.TokenType == TokenType.Assign)
        {
            Advance(); // Consume '='
            initialValue = ParseExpression(); // Parse the expression for the initial value
        }

        return new VariableDeclarationNode(variableType, variableName, initialValue);
    }

    /// <summary>
    /// Parses a write statement.
    /// Example: "написать "Hello, World!"".
    /// </summary>
    /// <returns>A WriteStatementNode.</returns>
    private WriteStatementNode ParseWriteStatement()
    {
        Expect(TokenType.Write); // Consume "написать"
        IAstNode expression = ParseExpression(); // The expression to write
        Expect(TokenType.Semicolon);
        return new WriteStatementNode(expression);
    }

    /// <summary>
    /// Parses a read statement.
    /// Example: "прочитать X;".
    /// </summary>
    /// <returns>A ReadStatementNode.</returns>
    private ReadStatementNode ParseReadStatement()
    {
        Expect(TokenType.Read); // Consume "прочитать"
        IToken variableNameToken = Expect(TokenType.VariableName);
        Expect(TokenType.Semicolon);
        return new ReadStatementNode(new VariableReferenceNode(TokenType.VariableName, variableNameToken.Representation));
    }


    /// <summary>
    /// Parses an IF-ELSE control flow statement.
    /// Example: "если Condition то Statement1 иначе Statement2 кесли;".
    /// </summary>
    /// <returns>An IfElseControlFlowNode.</returns>
    private IfElseControlFlowNode ParseIfStatement()
    {
        Expect(TokenType.If); // Consume "если"
        IAstNode condition = ParseExpression(); // Parse the condition expression
        Expect(TokenType.ControlBegin); // Consume "то"

        List<IAstNode> ifBody = new();
        while (CurrentToken.TokenType != TokenType.Else && CurrentToken.TokenType != TokenType.ControlEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            ifBody.Add(ParseStatement());
        }

        List<IAstNode>? elseBody = null;
        if (CurrentToken.TokenType == TokenType.Else)
        {
            Advance(); // Consume "иначе"
            elseBody = new List<IAstNode>();
            while (CurrentToken.TokenType != TokenType.ControlEnd && CurrentToken.TokenType != TokenType.Eof)
            {
                elseBody.Add(ParseStatement());
            }
        }
        Expect(TokenType.ControlEnd); // Consume "кесли"
        // Semicolon is expected by ParseStatement after this method returns
        return new IfElseControlFlowNode(condition, ifBody, elseBody);
    }

    /// <summary>
    /// Parses a loop statement.
    /// Example: "нц 5 раз Statement1 кц;".
    /// </summary>
    /// <returns>A LoopControlFlowNode.</returns>
    private LoopControlFlowNode ParseLoopStatement()
    {
        Expect(TokenType.LoopBegin); // Consume "нц"
        IAstNode times = ParseExpression(); // Parse the number of loop iterations
        Expect(TokenType.LoopTimes); // Consume "раз"

        List<IAstNode> loopBody = new();
        while (CurrentToken.TokenType != TokenType.LoopEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            loopBody.Add(ParseStatement());
        }
        Expect(TokenType.LoopEnd); // Consume "кц"
        return new LoopControlFlowNode(times, loopBody);
    }

    /// <summary>
    /// Parses a return statement.
    /// Example: "вернуть 0;".
    /// </summary>
    /// <returns>A ReturnNode.</returns>
    private ReturnNode ParseReturnStatement()
    {
        Expect(TokenType.Return); // Consume "вернуть"
        IAstNode expression = ParseExpression(); // The expression to return
        Expect(TokenType.Semicolon);
        return new ReturnNode(expression);
    }

    /// <summary>
    /// Parses an expression based on operator precedence (lowest to highest).
    /// </summary>
    /// <returns>An AST node representing the expression.</returns>
    /// <exception cref="SyntaxException">Thrown if an invalid expression is encountered.</exception>
    private IAstNode ParseExpression()
    {
        // Start with the lowest precedence: assignment
        return ParseAssignmentExpression();
    }

    /// <summary>
    /// Parses an assignment expression (e.g., X = 5, A = B = C).
    /// </summary>
    /// <returns>An IAstNode representing the assignment or the parsed left-hand side.</returns>
    private IAstNode ParseAssignmentExpression()
    {
        // This ensures right-associativity for assignments.
        // Example: A = B = C will parse as A = (B = C)
        IAstNode left = ParseEqualityExpression();

        if (CurrentToken.TokenType == TokenType.Assign)
        {
            IToken op = Advance(); // Consume '='
            IAstNode right = ParseAssignmentExpression(); // Recursively parse the right side
            return new BinaryExpressionNode(left, op.TokenType, right);
        }

        return left; // Not an assignment, just return the parsed expression
    }

    /// <summary>
    /// Parses an equality expression (e.g., X == Y).
    /// </summary>
    /// <returns>An IAstNode representing the equality expression or the next higher precedence expression.</returns>
    private IAstNode ParseEqualityExpression()
    {
        IAstNode left = ParseAdditiveExpression(); // Arithmetic expressions have higher precedence than equality

        while (CurrentToken.TokenType == TokenType.Equals)
        {
            IToken op = Advance(); // Consume '=='
            IAstNode right = ParseAdditiveExpression();
            left = new BinaryExpressionNode(left, op.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses an additive expression (e.g., 1 + 2, X - Y).
    /// </summary>
    /// <returns>An IAstNode representing the additive expression or the next higher precedence expression.</returns>
    private IAstNode ParseAdditiveExpression()
    {
        IAstNode left = ParseMultiplicativeExpression();

        while (CurrentToken.TokenType == TokenType.Add || CurrentToken.TokenType == TokenType.Decrement)
        {
            IToken op = Advance();
            IAstNode right = ParseMultiplicativeExpression();
            left = new BinaryExpressionNode(left, op.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses a multiplicative expression (e.g., 2 * 3, A / B).
    /// </summary>
    /// <returns>An IAstNode representing the multiplicative expression or the next higher precedence expression.</returns>
    private IAstNode ParseMultiplicativeExpression()
    {
        IAstNode left = ParsePrimaryExpression();

        while (CurrentToken.TokenType == TokenType.Multiply || CurrentToken.TokenType == TokenType.Divide)
        {
            IToken op = Advance();
            IAstNode right = ParsePrimaryExpression();
            left = new BinaryExpressionNode(left, op.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses a primary expression (literals, variable references, parenthesized expressions).
    /// </summary>
    /// <returns>An IAstNode representing the primary expression.</returns>
    /// <exception cref="SyntaxException">Thrown if an unexpected token is encountered.</exception>
    private IAstNode ParsePrimaryExpression()
    {
        if (CurrentToken.TokenType == TokenType.Integer)
        {
            return ParseIntegerLiteral();
        }
        else if (CurrentToken.TokenType == TokenType.Double)
        {
            return ParseDoubleLiteral();
        }
        else if (CurrentToken.TokenType == TokenType.String)
        {
            return ParseStringLiteral();
        }
        else if (CurrentToken.TokenType == TokenType.VariableName)
        {
            IToken varNameToken = Advance();
            // VariableReferenceNode now expects a TokenType for the variable type.
            // Since we don't have a symbol table during parsing, we pass TokenType.VariableName as a placeholder
            // for the VariableType. Semantic analysis would resolve this to the actual declared type.
            return new VariableReferenceNode(TokenType.VariableName, varNameToken.Representation);
        }
        // If parentheses are part of your grammar for grouping expressions
        else if (CurrentToken.TokenType == TokenType.ControlBegin) 
        {
            Advance(); 
            IAstNode expression = ParseExpression();
            Expect(TokenType.ControlEnd); 
            return expression;
        }
        throw new SyntaxException($"ParsePrimaryExpression: Unexpected token '{CurrentToken.Representation}' ({CurrentToken.TokenType}) at position {_position}. Expected a primary expression (literal or variable name).");
    }

    /// <summary>
    /// Parses an integer literal.
    /// </summary>
    /// <returns>An IntegerLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid integer literal.</exception>
    private IntegerLiteralNode ParseIntegerLiteral()
    {
        IToken token = Expect(TokenType.Integer);
        if (int.TryParse(token.Representation, out int value))
        {
            return new IntegerLiteralNode(value);
        }
        throw new SyntaxException($"Invalid integer literal: '{token.Representation}'.");
    }

    /// <summary>
    /// Parses a double literal.
    /// </summary>
    /// <returns>A DoubleLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid double literal.</exception>
    private DoubleLiteralNode ParseDoubleLiteral()
    {
        IToken token = Expect(TokenType.Double);
        if (double.TryParse(token.Representation, out double value))
        {
            return new DoubleLiteralNode(value);
        }
        throw new SyntaxException($"Invalid double literal: '{token.Representation}'.");
    }

    /// <summary>
    /// Parses a string literal.
    /// </summary>
    /// <returns>A StringLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid string literal.</exception>
    private StringLiteralNode ParseStringLiteral()
    {
        IToken token = Expect(TokenType.String);
        // Remove quotes from the string representation
        string stringValue = token.Representation.Trim('\"');
        return new StringLiteralNode(stringValue);
    }
}

/// <summary>
/// Represents an exception that occurs during the parsing process due to a syntax error.
/// </summary>
public class SyntaxException(string message) : Exception(message) { }