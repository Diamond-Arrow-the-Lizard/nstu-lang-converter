using Core.Parser.AST.Nodes;
using Core.Parser.Interfaces.Models;
using Core.Parser.Interfaces.Repositories;
using Core.Parser.Tokens;
using Core.Parser.Interfaces.AST;
using Core.Parser.AST.Nodes.StatementNodes;
using Core.Parser.AST.Nodes.ControlFlowNodes.LoopControlFlowNodes;
using Core.Parser.AST.Nodes.ControlFlowNodes.IfElseControlFlowNodes;
using Core.Parser.AST.Nodes.LiteralNodes;
using Core.Parser.AST.Nodes.ExpressionNodes;

namespace Core.Parser.AST.ASTParser;

/// <summary>
/// Implements a recursive descent parser to construct an Abstract Syntax Tree (AST)
/// from a stream of tokens.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="Parser"/> class.
/// </remarks>
/// <param name="tokenRepository">The repository containing the token stream generated by the lexer.</param>
public class Parser(ITokenRepository tokenRepository) : IParser
{
    public List<IToken> Tokens { get; set; } = tokenRepository.GetAllTokens().ToList();
    private int _position = 0;
    private readonly Dictionary<string, TokenType> _symbolTable = [];

    /// <summary>
    /// Gets the current token at the parser's current position.
    /// </summary>
    private IToken CurrentToken => Tokens[_position];

    /// <summary>
    /// Peeks at the next token without advancing the parser's position.
    /// </summary>
    /// <param name="offset">The offset from the current position to peek (default is 1 for the next token).</param>
    /// <returns>The token at the peeked position, or null if beyond the token stream.</returns>
    private IToken? Peek(int offset = 1)
    {
        int peekPosition = _position + offset;
        if (peekPosition < Tokens.Count)
        {
            return Tokens[peekPosition];
        }
        return null;
    }

    /// <summary>
    /// Consumes the current token and advances the parser's position.
    /// </summary>
    /// <returns>The consumed token.</returns>
    private IToken Advance()
    {
        return Tokens[_position++];
    }

    /// <summary>
    /// Expects the current token to be of a specific type and consumes it.
    /// Throws a SyntaxException if the current token's type does not match the expected type.
    /// </summary>
    /// <param name="tokenType">The expected TokenType.</param>
    /// <returns>The consumed token.</returns>
    /// <exception cref="SyntaxException">Thrown if the current token is not of the expected type.</exception>
    private IToken Expect(TokenType tokenType)
    {
        IToken token = CurrentToken;
        if (token.TokenType == tokenType)
        {
            Advance();
            return token;
        }
        throw new SyntaxException($"Expected {tokenType} but found {token.TokenType} at position {_position - 1}.");
    }

    /// <summary>
    /// Checks if the current token is of a specific type without consuming it.
    /// </summary>
    /// <param name="tokenType">The TokenType to check against.</param>
    /// <returns>True if the current token matches the type, false otherwise.</returns>
    private bool Match(TokenType tokenType)
    {
        return CurrentToken.TokenType == tokenType;
    }

    /// <summary>
    /// Parses the entire program and constructs the root ProgramNode of the AST.
    /// </summary>
    /// <returns>A ProgramNode representing the parsed program.</returns>
    public ProgramNode Parse()
    {
        Expect(TokenType.ProgramBegin); // Expect 'начало'
        List<IAstNode> statements = new();

        while (CurrentToken.TokenType != TokenType.ProgramEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            IAstNode? statement = ParseStatement();
            if (statement != null)
            {
                statements.Add(statement);
            }
        }

        Expect(TokenType.ProgramEnd); // Expect 'конец'
        Expect(TokenType.Eof); // Ensure end of file

        return new ProgramNode(statements);
    }

    /// <summary>
    /// Parses a single statement.
    /// </summary>
    /// <returns>An IAstNode representing the parsed statement, or null if no statement is found.</returns>
    /// <exception cref="SyntaxException">Thrown for unexpected token types.</exception>
    private IAstNode? ParseStatement()
    {
        IAstNode? statement;

        // Try to parse different types of statements
        if (Match(TokenType.IntegerType) || Match(TokenType.DoubleType) || Match(TokenType.StringType))
        {
            statement = ParseVariableDeclaration();
        }
        else if (Match(TokenType.VariableName) && Peek()?.TokenType == TokenType.Assign)
        {
            statement = ParseAssignmentStatement();
        }
        else if (Match(TokenType.If))
        {
            statement = ParseIfElseStatement();
        }
        else if (Match(TokenType.LoopBegin))
        {
            statement = ParseLoopStatement();
        }
        else if (Match(TokenType.Write))
        {
            statement = ParseWriteStatement();
        }
        else if (Match(TokenType.Read))
        {
            statement = ParseReadStatement();
        }
        else if (Match(TokenType.Return))
        {
            statement = ParseReturnStatement();
        }
        else
        {
            throw new SyntaxException($"Unexpected token type {CurrentToken.TokenType} at position {_position}. Expected a statement start.");
        }

        if (statement is not IfElseControlFlowNode && statement is not LoopControlFlowNode)
        {
            Expect(TokenType.Semicolon); // Expect ';'
        }

        return statement;
    }

    /// <summary>
    /// Parses a variable declaration statement.
    /// Examples: "цел X;", "плав Y = 10.5;", "строка Message = \"Hello\";".
    /// </summary>
    /// <returns>A VariableDeclarationNode.</returns>
    private VariableDeclarationNode ParseVariableDeclaration()
    {
        TokenType variableType = CurrentToken.TokenType;
        Advance(); // Consume the type token (цел, плав, строка)

        IToken variableNameToken = Expect(TokenType.VariableName); // Consume variable name
        string variableName = variableNameToken.Representation;

        IAstNode? initialValueExpression = null;
        if (Match(TokenType.Assign))
        {
            Advance(); // Consume '='
            initialValueExpression = ParseExpression(); // Parse the initial value expression
        }

        if (_symbolTable.ContainsKey(variableName))
        {
            throw new SyntaxException($"Variable '{variableName}' already declared.");
        }
        _symbolTable[variableName] = variableType; // Store the actual declared type

        return new VariableDeclarationNode(variableType, variableName, initialValueExpression);
    }

    /// <summary>
    /// Parses an assignment statement.
    /// Examples: "X = 5;", "Message = \"New text\";".
    /// </summary>
    /// <returns>A BinaryExpressionNode representing the assignment.</returns>
    private BinaryExpressionNode ParseAssignmentStatement()
    {
        IAstNode left = ParseVariableReference(); // Use the new helper for variable reference

        Expect(TokenType.Assign); // Expect '='

        IAstNode right = ParseExpression(); // Parse the right-hand side expression

        return new BinaryExpressionNode(left, TokenType.Assign, right);
    }

    /// <summary>
    /// NEW: Parses a variable reference and resolves its type from the symbol table.
    /// </summary>
    /// <returns>A VariableReferenceNode with the resolved type.</returns>
    /// <exception cref="SyntaxException">Thrown if the variable is not declared.</exception>
    private VariableReferenceNode ParseVariableReference()
    {
        IToken variableNameToken = Expect(TokenType.VariableName);
        string variableName = variableNameToken.Representation;

        if (!_symbolTable.TryGetValue(variableName, out TokenType declaredType))
        {
            throw new SyntaxException($"Undeclared variable '{variableName}' at position {_position - 1}.");
        }

        return new VariableReferenceNode(declaredType, variableName);
    }

    /// <summary>
    /// Parses an if-else control flow statement.
    /// Example: "если (условие) то <statements> иначе <statements> кесли".
    /// </summary>
    /// <returns>An IfElseControlFlowNode.</returns>
    private IfElseControlFlowNode ParseIfElseStatement()
    {
        Expect(TokenType.If); // Consume 'если'

        IAstNode condition = ParseExpression(); 

        Expect(TokenType.ControlBegin); // Expect 'то'

        List<IAstNode> thenBlock = new();
        while (CurrentToken.TokenType != TokenType.Else && CurrentToken.TokenType != TokenType.ControlEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            IAstNode? statement = ParseStatement();
            if (statement != null)
            {
                thenBlock.Add(statement);
            }
        }

        List<IAstNode>? elseBlock = null;
        if (Match(TokenType.Else))
        {
            Advance(); // Consume 'иначе'
            elseBlock = new List<IAstNode>();
            while (CurrentToken.TokenType != TokenType.ControlEnd && CurrentToken.TokenType != TokenType.Eof)
            {
                IAstNode? statement = ParseStatement();
                if (statement != null)
                {
                    elseBlock.Add(statement);
                }
            }
        }

        Expect(TokenType.ControlEnd); // Expect 'кесли'
        return new IfElseControlFlowNode(condition, thenBlock, elseBlock);
    }

    /// <summary>
    /// Parses a loop control flow statement.
    /// Example: "нц 5 раз <statements> кц".
    /// </summary>
    /// <returns>A LoopControlFlowNode.</returns>
    private LoopControlFlowNode ParseLoopStatement()
    {
        Expect(TokenType.LoopBegin); // Consume 'нц'

        IAstNode loopCountExpression = ParsePrimaryExpression(); // Expect an integer literal or variable for loop count

        Expect(TokenType.LoopTimes); // Expect 'раз'

        List<IAstNode> body = new();
        while (CurrentToken.TokenType != TokenType.LoopEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            IAstNode? statement = ParseStatement();
            if (statement != null)
            {
                body.Add(statement);
            }
        }

        Expect(TokenType.LoopEnd); // Expect 'кц'
        return new LoopControlFlowNode(loopCountExpression, body);
    }

    /// <summary>
    /// Parses a write statement.
    /// Example: "написать \"Hello, World!\";" or "написать X;".
    /// </summary>
    /// <returns>A WriteStatementNode.</returns>
    private WriteStatementNode ParseWriteStatement()
    {
        Expect(TokenType.Write); // Consume 'написать'
        IAstNode expressionToOutput = ParseExpression(); // The expression whose value will be written
        return new WriteStatementNode(expressionToOutput);
    }

    /// <summary>
    /// Parses a read statement.
    /// Example: "прочитать X;".
    /// </summary>
    /// <returns>A ReadStatementNode.</returns>
    private ReadStatementNode ParseReadStatement()
    {
        Expect(TokenType.Read); // Consume 'прочитать'
        VariableReferenceNode targetVariable = ParseVariableReference();
        return new ReadStatementNode(targetVariable);
    }

    /// <summary>
    /// Parses a return statement.
    /// Example: "вернуть 10;".
    /// </summary>
    /// <returns>A ReturnNode.</returns>
    private ReturnNode ParseReturnStatement()
    {
        Expect(TokenType.Return); // Consume 'вернуть'
        IAstNode expressionToReturn = ParseExpression(); // The expression whose value will be returned
        return new ReturnNode(expressionToReturn);
    }

    /// <summary>
    /// Parses a general expression, applying operator precedence (simplified).
    /// </summary>
    /// <returns>An IAstNode representing the parsed expression.</returns>
    private IAstNode ParseExpression()
    {
        return ParseAssignment();
    }

    /// <summary>
    /// Parses an assignment expression.
    /// </summary>
    /// <returns>An IAstNode representing the assignment or the next level of expression.</returns>
    private IAstNode ParseAssignment()
    {
        IAstNode left = ParseEquality(); // Start with equality/comparison expressions

        if (Match(TokenType.Assign))
        {
            IToken assignToken = Advance(); // Consume '='
            IAstNode right = ParseAssignment(); // Assignment is right-associative

            if (left is not VariableReferenceNode varRef)
            {
                throw new SyntaxException($"Invalid assignment target. Expected a variable on the left side of '=' at position {_position - 1}.");
            }
            return new BinaryExpressionNode(left, assignToken.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses equality expressions (==).
    /// </summary>
    /// <returns>An IAstNode representing the equality expression or the next level.</returns>
    private IAstNode ParseEquality()
    {
        IAstNode left = ParseAdditive(); // Start with additive expressions

        while (Match(TokenType.Equals))
        {
            IToken operatorToken = Advance(); // Consume '=='
            IAstNode right = ParseAdditive(); // Right side is also additive
            left = new BinaryExpressionNode(left, operatorToken.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses additive and subtractive expressions (+, -).
    /// </summary>
    /// <returns>An IAstNode representing the additive/subtractive expression or the next level.</returns>
    private IAstNode ParseAdditive()
    {
        IAstNode left = ParseMultiplicative(); // Start with multiplicative expressions

        while (Match(TokenType.Add) || Match(TokenType.Decrement))
        {
            IToken operatorToken = Advance(); // Consume '+' or '-'
            IAstNode right = ParseMultiplicative(); // Right side is multiplicative
            left = new BinaryExpressionNode(left, operatorToken.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses multiplicative and divisive expressions (*, /).
    /// </summary>
    /// <returns>An IAstNode representing the multiplicative/divisive expression or the next level.</returns>
    private IAstNode ParseMultiplicative()
    {
        IAstNode left = ParsePrimaryExpression(); // Start with primary expressions

        while (Match(TokenType.Multiply) || Match(TokenType.Divide))
        {
            IToken operatorToken = Advance(); // Consume '*' or '/'
            IAstNode right = ParsePrimaryExpression(); // Right side is primary
            left = new BinaryExpressionNode(left, operatorToken.TokenType, right);
        }

        return left;
    }

    /// <summary>
    /// Parses a primary expression (literals, variable references, parenthesized expressions).
    /// </summary>
    /// <returns>An IAstNode representing the primary expression.</returns>
    /// <exception cref="SyntaxException">Thrown for unexpected token types.</exception>
    private IAstNode ParsePrimaryExpression()
    {
        if (Match(TokenType.Integer))
        {
            return ParseIntegerLiteral();
        }
        else if (Match(TokenType.Double))
        {
            return ParseDoubleLiteral();
        }
        else if (Match(TokenType.String))
        {
            return ParseStringLiteral();
        }
        else if (Match(TokenType.VariableName))
        {
            return ParseVariableReference();
        }
        else if (Match(TokenType.ControlBegin)) // Parenthesized expression
        {
            Advance(); 
            IAstNode expr = ParseExpression();
            Expect(TokenType.ControlEnd); 
            return expr;
        }

        throw new SyntaxException($"Unexpected token {CurrentToken.TokenType} while parsing primary expression at position {_position}.");
    }

    /// <summary>
    /// Parses an integer literal.
    /// </summary>
    /// <returns>An IntegerLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid integer literal.</exception>
    private IntegerLiteralNode ParseIntegerLiteral()
    {
        IToken token = Expect(TokenType.Integer);
        if (int.TryParse(token.Representation, out int value))
        {
            return new IntegerLiteralNode(value);
        }
        throw new SyntaxException($"Invalid integer literal: '{token.Representation}'.");
    }

    /// <summary>
    /// Parses a double literal.
    /// </summary>
    /// <returns>A DoubleLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid double literal.</exception>
    private DoubleLiteralNode ParseDoubleLiteral()
    {
        IToken token = Expect(TokenType.Double);
        if (double.TryParse(token.Representation, out double value))
        {
            return new DoubleLiteralNode(value);
        }
        throw new SyntaxException($"Invalid double literal: '{token.Representation}'.");
    }

    /// <summary>
    /// Parses a string literal.
    /// </summary>
    /// <returns>A StringLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid string literal.</exception>
    private StringLiteralNode ParseStringLiteral()
    {
        IToken token = Expect(TokenType.String);
        string stringValue = token.Representation.Trim('\"');
        return new StringLiteralNode(stringValue);
    }
}

/// <summary>
/// Represents an exception that occurs during the parsing process due to a syntax error.
/// </summary>
public class SyntaxException(string message) : Exception(message) { }