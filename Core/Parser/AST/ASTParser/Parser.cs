using Core.Parser.AST.Nodes;
using Core.Parser.Interfaces.Models;
using Core.Parser.Interfaces.Repositories;
using Core.Parser.Models;
using Core.Parser.Tokens;
using Core.Parser.Interfaces.AST;
using Core.Parser.AST.Nodes.StatementNodes;
using Core.Parser.AST.Nodes.ControlFlowNodes.LoopControlFlowNodes;
using Core.Parser.AST.Nodes.ControlFlowNodes.IfElseControlFlowNodes;
using Core.Parser.AST.Nodes.LiteralNodes;

namespace Core.Parser.AST.ASTParser;

/// <summary>
/// Implements a recursive descent parser to construct an Abstract Syntax Tree (AST)
/// from a stream of tokens.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="Parser"/> class.
/// </remarks>
/// <param name="tokenRepository">The repository containing the token stream generated by the lexer.</param>
public class Parser(ITokenRepository tokenRepository) : IParser
{
    private readonly List<IToken> _tokens = tokenRepository.GetAllTokens().ToList();
    private int _position = 0;

    /// <summary>
    /// Gets the current token at the parser's current position.
    /// </summary>
    private IToken CurrentToken => _tokens[_position];

    /// <summary>
    /// Peeks at the next token without advancing the parser's position.
    /// </summary>
    /// <param name="offset">The offset from the current position to peek (default is 1 for the next token).</param>
    /// <returns>The token at the peeked position, or Eof if beyond bounds.</returns>
    private IToken Peek(int offset = 1)
    {
        int peekPosition = _position + offset;
        if (peekPosition >= _tokens.Count)
        {
            // Return Eof token if we're trying to peek beyond the end of the token stream.
            // This is a common practice to simplify grammar rules by always having a token.
            return new Token(TokenType.Eof, ""); // Using concrete Token, adjust if IToken has static Eof factory.
        }
        return _tokens[peekPosition];
    }

    /// <summary>
    /// Advances the parser's position to the next token.
    /// </summary>
    private void Advance()
    {
        if (_position < _tokens.Count)
        {
            _position++;
        }
    }

    /// <summary>
    /// Consumes the current token if its type matches the expected type, then advances.
    /// Throws a <see cref="SyntaxException"/> if the type does not match.
    /// </summary>
    /// <param name="expectedType">The expected token type.</param>
    /// <returns>The consumed token.</returns>
    /// <exception cref="SyntaxException">Thrown if the current token type does not match the expected type.</exception>
    private IToken Expect(TokenType expectedType)
    {
        if (CurrentToken.TokenType == expectedType)
        {
            IToken consumedToken = CurrentToken;
            Advance();
            return consumedToken;
        }
        throw new SyntaxException($"Expected token type {expectedType}, but found {CurrentToken.TokenType} ('{CurrentToken.Representation}') at position {_position}.");
    }

    /// <summary>
    /// The main entry point for parsing. Parses the entire program and returns the root AST node.
    /// Grammar Rule: Program -> 'начало' Statement* 'конец' Eof
    /// </summary>
    /// <returns>The root ProgramNode of the AST.</returns>
    public ProgramNode Parse()
    {
        Expect(TokenType.ProgramBegin);

        List<IAstNode> statements = [];

        // Parse statements until 'конец' (ProgramEnd)
        while (CurrentToken.TokenType != TokenType.ProgramEnd)
        {
            statements.Add(ParseStatement());
        }

        Expect(TokenType.ProgramEnd);

        // Expect Eof to ensure no extra tokens after the program
        Expect(TokenType.Eof);

        return new ProgramNode(statements);
    }


    /// <summary>
    /// Parses a single statement.
    /// This method will act as a dispatcher to other parsing methods based on the current token.
    /// Grammar Rule: Statement -> VariableDeclaration | ReturnStatement | WriteStatement | ReadStatement | LoopStatement | IfStatement | AssignmentStatement | ExpressionStatement
    /// </summary>
    /// <returns>An IAstNode representing the parsed statement.</returns>
    /// <exception cref="SyntaxException">Thrown if an unexpected token is encountered.</exception>
    private IAstNode ParseStatement()
    {
        IAstNode statement;
        TokenType initialTokenType = CurrentToken.TokenType;

        if (initialTokenType == TokenType.VariableName && Peek(1).TokenType == TokenType.Assign)
        {
            statement = ParseExpression();
        }
        else
        {
            statement = initialTokenType switch
            {
                TokenType.IntegerType or TokenType.DoubleType or TokenType.StringType => ParseVariableDeclaration(),
                TokenType.Return => ParseReturnStatement(),
                TokenType.Write => ParseWriteStatement(),
                TokenType.Read => ParseReadStatement(),
                TokenType.LoopBegin => ParseLoopStatement(),
                TokenType.If => ParseIfStatement(),
                _ => throw new SyntaxException($"Unexpected token '{CurrentToken.Representation}' ({CurrentToken.TokenType}) at position {_position}. Expected a statement."),
            };
        }

        // Consume semicolon ONLY if the statement was a simple statement (not a block)
        // This requires knowing if the parsed statement was a 'block' type or not.
        // A more robust way is to have specific parsing methods for 'simpleStatement' vs 'blockStatement'.
        // For now, based on the current types in switch:
        // VariableDeclaration, ReturnStatement, WriteStatement, ReadStatement, AssignmentExpression
        // are simple statements that should be followed by a semicolon.
        // LoopStatement, IfStatement are block statements and should NOT be followed by a semicolon.

        // Check if the current statement *type* is one that expects a semicolon.
        // Instead of checking 'CurrentToken.TokenType', which would be the token *after* the statement,
        // we need to know what kind of statement was just parsed.
        bool expectsSemicolon =
            statement is VariableDeclarationNode ||
            statement is ReturnNode ||
            statement is WriteStatementNode ||
            statement is ReadStatementNode ||
            (statement is BinaryExpressionNode binaryExpr && binaryExpr.Operator == TokenType.Assign);

        if (expectsSemicolon)
        {
            Expect(TokenType.Semicolon);
        }

        return statement;
    }

    /// <summary>
    /// Parses a variable declaration statement.
    /// Grammar Rule: VariableDeclaration -> (IntegerType | DoubleType | StringType) VariableName ('=' Expression)? ';'
    /// </summary>
    /// <returns>A VariableDeclarationNode.</returns>
    private VariableDeclarationNode ParseVariableDeclaration()
    {
        TokenType variableTypeToken = CurrentToken.TokenType;
        Expect(variableTypeToken); // Consume 'цел', 'плав', or 'строка'

        IToken variableNameToken = Expect(TokenType.VariableName); // Consume variable name

        IAstNode? initialValue = null;
        if (CurrentToken.TokenType == TokenType.Assign) // '='
        {
            Advance(); // Consume '='
            initialValue = ParseExpression(); // Parse the expression for initial value
        }

        return new VariableDeclarationNode(variableTypeToken, variableNameToken.Representation, initialValue);
    }

    /// <summary>
    /// Parses a return statement.
    /// Grammar Rule: ReturnStatement -> 'вернуть' Expression? ';'
    /// </summary>
    /// <returns>A ReturnNode.</returns>
    private ReturnNode ParseReturnStatement()
    {
        Expect(TokenType.Return); // Consume 'вернуть'

        IAstNode? expression = null;
        // If the next token is not Eof (semicolon), then there's an expression to parse.
        // This assumes 'вернуть;' is valid for void return, and 'вернуть expr;' for value return.
        // Also check for block ending tokens to allow 'return X' inside a block without a semicolon.
        if (CurrentToken.TokenType != TokenType.Eof &&
            CurrentToken.TokenType != TokenType.ProgramEnd &&
            CurrentToken.TokenType != TokenType.ControlEnd &&
            CurrentToken.TokenType != TokenType.LoopEnd)
        {
            expression = ParseExpression();
        }

        return new ReturnNode(expression);
    }

    /// <summary>
    /// Parses a write statement.
    /// Grammar Rule: WriteStatement -> 'написать' Expression ';'
    /// </summary>
    /// <returns>A WriteStatementNode.</returns>
    private WriteStatementNode ParseWriteStatement()
    {
        Expect(TokenType.Write); // Consume 'написать'
        IAstNode expression = ParseExpression(); // Must have an expression

        return new WriteStatementNode(expression);
    }

    /// <summary>
    /// Parses a read statement.
    /// Grammar Rule: ReadStatement -> 'прочитать' VariableName ';'
    /// </summary>
    /// <returns>A ReadStatementNode.</returns>
    private ReadStatementNode ParseReadStatement()
    {
        Expect(TokenType.Read); // Consume 'прочитать'
        IToken variableNameToken = Expect(TokenType.VariableName);

        VariableReferenceNode targetVariable = new(TokenType.VariableName, variableNameToken.Representation);

        return new ReadStatementNode(targetVariable);
    }

    /// <summary>
    /// Parses a loop statement.
    /// Grammar Rule: LoopStatement -> 'нц' (IntegerLiteral | VariableName) 'раз' Statement* 'кц'
    /// </summary>
    /// <returns>A LoopControlFlowNode.</returns>
    private LoopControlFlowNode ParseLoopStatement()
    {
        Expect(TokenType.LoopBegin); // Consume 'нц'

        // The loop count expression can be an integer literal or a variable reference
        IAstNode loopCountExpression;
        if (CurrentToken.TokenType == TokenType.Integer)
        {
            loopCountExpression = ParseIntegerLiteral();
        }
        else if (CurrentToken.TokenType == TokenType.VariableName)
        {
            // Assuming variable reference as loop count for now. Type check later.
            IToken variableNameToken = Expect(TokenType.VariableName);
            loopCountExpression = new VariableReferenceNode(TokenType.VariableName, variableNameToken.Representation); // Placeholder type
        }
        else
        {
            throw new SyntaxException($"Expected an integer literal or variable name for loop count, but found {CurrentToken.TokenType} at position {_position}.");
        }

        Expect(TokenType.LoopTimes); // Consume 'раз'

        List<IAstNode> loopBody = [];
        while (CurrentToken.TokenType != TokenType.LoopEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            loopBody.Add(ParseStatement());
        }

        Expect(TokenType.LoopEnd); // Consume 'кц'

        return new LoopControlFlowNode(loopCountExpression, loopBody);
    }

    /// <summary>
    /// Parses an if statement.
    /// Grammar Rule: IfStatement -> 'если' Expression 'то' Statement* ('иначе' Statement*)? 'кесли'
    /// </summary>
    /// <returns>An IfElseControlFlowNode.</returns>
    private IfElseControlFlowNode ParseIfStatement()
    {
        Expect(TokenType.If); // Consume 'если'

        IAstNode condition = ParseExpression(); // Parse the condition expression

        Expect(TokenType.ControlBegin); // Consume 'то'

        List<IAstNode> thenBlock = [];
        // Loop until 'иначе', 'кесли', or Eof
        while (CurrentToken.TokenType != TokenType.Else && CurrentToken.TokenType != TokenType.ControlEnd && CurrentToken.TokenType != TokenType.Eof)
        {
            thenBlock.Add(ParseStatement());
        }

        List<IAstNode>? elseBlock = null;
        if (CurrentToken.TokenType == TokenType.Else) // Optional 'иначе'
        {
            Advance(); // Consume 'иначе'
            elseBlock = [];
            // Loop until 'кесли' or Eof
            while (CurrentToken.TokenType != TokenType.ControlEnd && CurrentToken.TokenType != TokenType.Eof)
            {
                elseBlock.Add(ParseStatement());
            }
        }

        Expect(TokenType.ControlEnd); // Consume 'кесли'

        return new IfElseControlFlowNode(condition, thenBlock, elseBlock);
    }


    /// <summary>
    /// Parses a general expression, handling operator precedence (currently not fully implemented,
    /// just handles simple binary expressions and literals).
    /// Grammar Rule: Expression -> Term (('+' | '-') Term)* (simplified for now)
    /// </summary>
    /// <returns>An IAstNode representing the parsed expression.</returns>
    private IAstNode ParseExpression()
    {
        // For simplicity, we'll start with parsing simple terms (literals, variable references)
        // and then handle binary operations. This needs proper operator precedence parsing (e.g., Shunting-yard or precedence climbing).
        // For now, let's parse a "primary" expression first.
        IAstNode left = ParsePrimaryExpression();

        // Handle binary operators like +, -, *, /, =, ==
        while (IsBinaryOperator(CurrentToken.TokenType))
        {
            TokenType opType = CurrentToken.TokenType;
            Advance(); // Consume the operator

            IAstNode right = ParsePrimaryExpression(); // For now, assumes right operand is also a primary expression.
                                                       // This will need to be replaced with a proper precedence parser.

            left = new BinaryExpressionNode(left, opType, right);
        }

        return left;
    }

    /// <summary>
    /// Determines if a token type is a binary operator.
    /// </summary>
    private bool IsBinaryOperator(TokenType type)
    {
        return type == TokenType.Add ||
               type == TokenType.Decrement ||
               type == TokenType.Multiply ||
               type == TokenType.Divide ||
               type == TokenType.Assign || // Assignment is also a binary operator
               type == TokenType.Equals;
    }

    /// <summary>
    /// Parses a primary expression (e.g., a literal or a variable reference).
    /// </summary>
    /// <returns>An IAstNode representing the primary expression.</returns>
    /// <exception cref="SyntaxException">Thrown if an unexpected token is encountered.</exception>
    private IAstNode ParsePrimaryExpression()
    {
        IAstNode result;
        switch (CurrentToken.TokenType)
        {
            case TokenType.Integer:
                result = ParseIntegerLiteral();
                break;
            case TokenType.Double:
                result = ParseDoubleLiteral();
                break;
            case TokenType.String:
                result = ParseStringLiteral();
                break;
            case TokenType.VariableName:
                // When parsing a variable reference, we only know its name here.
                // Its actual type would be resolved during semantic analysis.
                // For now, we use TokenType.VariableName as a placeholder for its type.
                IToken variableToken = Expect(TokenType.VariableName);
                result = new VariableReferenceNode(TokenType.VariableName, variableToken.Representation);
                break;
            // TODO: Add support for parenthesized expressions, function calls etc.
            default:
                throw new SyntaxException($"Unexpected token '{CurrentToken.Representation}' ({CurrentToken.TokenType}) at position {_position}. Expected a literal or variable name for an expression.");
        }
        // Null checks for literal parsing methods are now handled inside those methods or by their return types.
        return result;
    }

    /// <summary>
    /// Parses an integer literal.
    /// </summary>
    /// <returns>An IntegerLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid integer literal.</exception>
    private IntegerLiteralNode ParseIntegerLiteral()
    {
        IToken token = Expect(TokenType.Integer);
        if (int.TryParse(token.Representation, out int value))
        {
            return new IntegerLiteralNode(value);
        }
        throw new SyntaxException($"Invalid integer literal: '{token.Representation}'.");
    }

    /// <summary>
    /// Parses a double literal.
    /// </summary>
    /// <returns>A DoubleLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid double literal.</exception>
    private DoubleLiteralNode ParseDoubleLiteral()
    {
        IToken token = Expect(TokenType.Double);
        if (double.TryParse(token.Representation, out double value))
        {
            return new DoubleLiteralNode(value);
        }
        throw new SyntaxException($"Invalid double literal: '{token.Representation}'.");
    }

    /// <summary>
    /// Parses a string literal.
    /// </summary>
    /// <returns>A StringLiteralNode.</returns>
    /// <exception cref="SyntaxException">Thrown if the token is not a valid string literal.</exception>
    private StringLiteralNode ParseStringLiteral()
    {
        IToken token = Expect(TokenType.String);
        // Remove quotes from the string representation
        string stringValue = token.Representation.Trim('"');
        return new StringLiteralNode(stringValue);
    }
}

/// <summary>
/// Represents an exception that occurs during the parsing process due to a syntax error.
/// </summary>
public class SyntaxException(string message) : Exception(message) { }